import path from 'path';
import fs from 'fs';
import { expect } from 'chai';
import sinon from 'sinon';
import { createRequire } from 'module';
import { fileURLToPath } from 'url';
import { indexFile } from '../documentor/indexing/fileIndexer.cjs';

const require = createRequire(import.meta.url);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const { indexManager } = require('../documentor/indexing/indexManager.cjs');

describe('documentResource', function() {
  let sandbox;
  let fakeOutputChannel;
  let fakeVscode;
  let documentGenerator;
  let fixturesDir;
  let samplePyPath;
  let sampleTxtPath;
  let chatAnswerStub;

  // Before running tests, create fixtures
  before(function() {
    fixturesDir = path.join(__dirname, 'fixtures');
    if (!fs.existsSync(fixturesDir)) {
      fs.mkdirSync(fixturesDir);
    }
    samplePyPath = path.join(fixturesDir, 'sample.py');
    sampleTxtPath = path.join(fixturesDir, 'sample.txt');
    // Simple Python file example
    fs.writeFileSync(samplePyPath, "def hello():\n    print('Hello, World!')\n", 'utf8');
    // Simple text file example
    fs.writeFileSync(sampleTxtPath, "This is a sample text file.", 'utf8');
  });

  after(function() {
    // Cleanup fixtures
    if (fs.existsSync(samplePyPath)) fs.unlinkSync(samplePyPath);
    if (fs.existsSync(sampleTxtPath)) fs.unlinkSync(sampleTxtPath);
    if (fs.existsSync(fixturesDir)) fs.rmdirSync(fixturesDir);
  });

  beforeEach(function() {
    // Clear module cache and create sandbox
    delete require.cache[require.resolve('../openaiClient.cjs')];
    delete require.cache[require.resolve('../documentor/documentGenerator.cjs')];
    sandbox = sinon.createSandbox();
    indexManager.clearProjectIndex(path.dirname(samplePyPath));
    // Add reset content of files to original state before each test
    fs.writeFileSync(samplePyPath, "def hello():\n    print('Hello, World!')\n", 'utf8');
    fs.writeFileSync(sampleTxtPath, "This is a sample text file.", 'utf8');
    
    // Existing fakeOutputChannel and fakeVscode setup (can be left if they are needed for other purposes)
    fakeOutputChannel = {
      show: sandbox.spy((msg) => {
        console.log("OutputChannel show:", msg);
      }),
      appendLine: sandbox.spy((line) => {
        console.log("OutputChannel appendLine:", line);
      })
    };
    
    fakeVscode = {
      window: {
        createOutputChannel: sandbox.stub().returns(fakeOutputChannel),
        showInformationMessage: sandbox.spy(),
        showErrorMessage: sandbox.spy()
      },
      workspace: {
        getConfiguration: sandbox.stub().returns({
          get: sandbox.stub().returns(undefined)
        })
      }
    };
    
    // Replace ChatGPTClient method answer, now with correct extension
    const ChatGPTClient = require('../openaiClient.cjs');
    chatAnswerStub = sandbox.stub(ChatGPTClient.prototype, 'answer').callsFake((request) => {
        console.log("Mocked ChatGPTClient answer():", request);
        if (request.includes("\"members\"")) {
            return Promise.resolve(JSON.stringify({ members: [
              { type: "function", name: "hello", description: "MOCKED MEMBER DESCRIPTION" }
            ]}));
        } else if (request.includes("\"docstring\"")) {
            return Promise.resolve(JSON.stringify({ docstring: "MOCKED DOCSTRING GENERATED BY LLM" }));
        } else if (request.includes("\"content\"")) {
            return Promise.resolve(JSON.stringify({ content: "MOCKED CONTENT GENERATED BY LLM" }));
        } else if (request.includes("\"description\"")) {
          return Promise.resolve(JSON.stringify({ description: "MOCKED DESCRIPTION GENERATED BY LLM" }));
        } else {
          console.log("Unknown request:", request);
        }
    });
    
    // Before setting require.cache, remove old values to ensure reload
    const openaiClientAbs = require.resolve(path.join(__dirname, '../openaiClient.cjs'));

    // Remove the module from cache if it already exists
    if(require.cache[openaiClientAbs]) {
      delete require.cache[openaiClientAbs];
    }

    const expectedPath = (() => {
      try {
        return require.resolve(path.join(__dirname, '../documentor/../../openaiClient.cjs'));
      } catch (e) {
        return null;
      }
    })();

    if(expectedPath && require.cache[expectedPath]) {
      delete require.cache[expectedPath];
    }

    // Устанавливаем require.cache для основного пути
    require.cache[openaiClientAbs] = { 
      id: openaiClientAbs,
      filename: openaiClientAbs,
      loaded: true,
      exports: ChatGPTClient 
    };

    // Если expectedPath найден и отличается, устанавливаем и для него
    if (expectedPath && expectedPath !== openaiClientAbs) {
      require.cache[expectedPath] = {
        id: expectedPath,
        filename: expectedPath,
        loaded: true,
        exports: ChatGPTClient
      };
    }
    
    // Заменяем зависимости openaiClient в proxyquire, используя абсолютные пути
    const proxyquire = require('proxyquire');
    const stubs = {
      'vscode': fakeVscode
    };

    stubs[require.resolve(path.join(__dirname, '../openaiClient.cjs'))] = ChatGPTClient;
    if (expectedPath) {
      stubs[expectedPath] = ChatGPTClient;
    }

    documentGenerator = proxyquire('../documentor/documentGenerator.cjs', stubs);

    // Инжектим замоканный vscode
    documentGenerator.setVscode(fakeVscode);

    // Добавляем дополнительное мокирование для fileIndexer.cjs
    const fileIndexerPath = require.resolve('../documentor/indexing/fileIndexer.cjs');
    proxyquire(fileIndexerPath, {
      '../../openaiClient.cjs': ChatGPTClient,
      'vscode': fakeVscode
    });
  });

  afterEach(function() {
    if (sandbox) sandbox.restore();
  });

  it('should correctly process Python file', async function() {
    const resource = { fsPath: samplePyPath };
    await documentGenerator.documentResource(resource);

    // Read file content after processing
    const updatedContent = fs.readFileSync(samplePyPath, 'utf8');
    // Check that the generated docstring is inserted into the file
    expect(updatedContent).to.equal("MOCKED CONTENT GENERATED BY LLM");
    // Check that the original function code is still present
    // expect(updatedContent).to.contain("def hello():");

    // Check that the LLM answer method was called once
    expect(chatAnswerStub.called).to.be.true;
  });

  it('should correctly process non-Python file', async function() {
    const resource = { fsPath: sampleTxtPath };
    await documentGenerator.documentResource(resource);

    // Read file content after processing
    const updatedContent = fs.readFileSync(sampleTxtPath, 'utf8');
    // Check that the original text remains and no docstring was added
    expect(updatedContent).to.contain("This is a sample text file.");
    expect(updatedContent).to.not.contain("MOCKED DOCSTRING GENERATED BY LLM");

    // Check that the LLM answer method was not called
    expect(chatAnswerStub.callCount).to.equal(3);
  });

  it('should log an error on processing failure', async function() {
    // Save the original file content
    const originalContent = fs.readFileSync(samplePyPath, 'utf8');
    const error = new Error("Test error");
    chatAnswerStub.rejects(error);
    const resource = { fsPath: samplePyPath };
    await documentGenerator.documentResource(resource);

    // Read file content after processing attempt that resulted in an error
    const updatedContent = fs.readFileSync(samplePyPath, 'utf8');
    // Expect that the file content remains unchanged
    expect(updatedContent).to.equal(originalContent);
  });
}); 